<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>SRFI 11: Binding and Control Expressions</title>
  </head>

  <body>

<H1>Title</H1>

Binding and Control Expressions

<H1>Author</H1>

Lars T Hansen

<H1>Status</H1>
This SRFI is currently in ``draft'' status.  To see an explanation of each status that a SRFI can hold, see <A HREF="http://srfi.schemers.org/srfi-process.html">here</A>.
It will remain in draft status until 1999/02/22, or as amended.
To provide input on this SRFI, please <code><A
HREF="mailto:srfi-11@srfi.schemers.org">mail to
&lt;srfi-11@srfi.schemers.org&gt;</A></code>.  See <A HREF=../srfi-list-subscribe.html>instructions here</A> to subscribe to the list.  You can access previous messages via <A HREF=mail-archive/maillist.html>the archive of the mailing list</A>.
<P><UL>
<LI>Received: 1999/09/10
<LI>Draft: 1998/09/14-1999/11/12
</UL>

<H1>Abstract</H1>

Three binding and control expressions are introduced:
<ul>
<li><code>LET-VALUES</code>, a syntax for receiving multiple values.
<li><code>FLUID-LET</code>, a syntax for overriding variables' values in a dynamic scope.
<li><code>CASE-LAMBDA</code>, a syntax for procedures with a variable number of arguments.
</ul>

<H1>Issues</H1>

None.

<H1>Rationale</H1>

Syntax is presented for three idioms.

<ul>
<li><code>LET-VALUES</code> reduces the clutter of the CALL-WITH-VALUES notation for
receiving multiple values.
<p>
<li><code>FLUID-LET</code> reduces the clutter of overriding the values of variables
in a dynamic scope while allowing nonlocal exits from and re-entries to
that scope.  Scheme systems have had <code>FLUID-LET</code> for years, though they do
not agree on its meaning.
<p>
<li><code>CASE-LAMBDA</code> reduces the clutter of procedures that execute different
code depending on the number of arguments they were passed; it is 
a pattern-matching mechanism that matches on the number of arguments.
<code>CASE-LAMBDA</code> is available in some Scheme systems.
</ul>

<p>While all three forms can be implemented as macros using only
facilities available in R5RS Scheme, they admit implementation-specific
optimization.


<H1>Specification</H1>

<dl>
<dt>
<code>(LET-VALUES (&lt;formals&gt; &lt;expression&gt;) &lt;body&gt;)</code>
<br>Syntax
<dd>
<p>&lt;Formals&gt; should be a formal arguments list as for a LAMBDA 
   expression, cf section 4.1.4 of the R5RS.

<p>The &lt;expression&gt; is evaluated in the current environment, the 
   variables of &lt;formals&gt; are bound to fresh locations, the return 
   values of &lt;expression&gt; are stored in the variables, the &lt;body&gt; 
   is evaluated in the extended environment, and the values of the
   last expression of &lt;body&gt; are returned.  The &lt;body&gt; is a 
   &lt;tail body&gt;, cf section 3.5 of the R5RS.

<p>The matching of &lt;formals&gt; to values is as for the matching of 
   &lt;formals&gt; to arguments in a LAMBDA expression, and it is an
   error for &lt;expression&gt; to return a number of values that does
   not match &lt;formals&gt;.

<pre>
             (let-values ((a b c) (values 1 2 3))
               (list a b c))            --&gt; (1 2 3)
             (let-values ((a b . c) (values 1 2 3 4))
               (list a b c))            --&gt; (1 2 (3 4))   
</pre>

<p><dt>
<code>(FLUID-LET &lt;bindings&gt; &lt;body&gt;)</code>
<br> Syntax
<dd>
<p>&lt;Bindings&gt; should have the form ((&lt;variable1&gt; &lt;init1&gt;) ...) where
   each &lt;init&gt; is an expression.  It is an error for a &lt;variable&gt;
   to appear more than once in the list of variables.

<p>The &lt;init&gt;s are evaluated in the current environment, the values 
   of the &lt;variable&gt;s are saved, the results of the &lt;init&gt;s are 
   assigned to the &lt;variable&gt;s, and the &lt;body&gt; is evaluated in the
   current environment before the &lt;variable&gt;s are restored to their
   saved values and the values returned by the last expression of &lt;body&gt;
   are returned as the values of the entire expression.

<p>It is an error for the &lt;variable&gt;s to be unbound at the time their
   old values are saved.

<p>If control leaves the dynamic scope of the &lt;body&gt; before the last 
   expression of &lt;body&gt; has returned, then the current values of the 
   &lt;variables&gt;s inside the scope are saved and the saved values from 
   outside the scope are restored before control leaves the scope of 
   the <code>FLUID-LET</code>.  If control subsequently re-enters the scope of the
   &lt;body&gt;, then the current values of the &lt;variable&gt;s outside 
   the scope
   are saved and the saved values from inside the scope are restored 
   before execution continues inside &lt;body&gt;.  In this case, it is the
   last saved values from outside the scope that will be restored when 
   the &lt;body&gt; finally returns.

<pre>
             (define v 1)
             (define again #f)

             (define (test1)
               (display v)
               (fluid-let ((v 2))
                 (call-with-current-continuation
                   (lambda (k)
                     (set! again (lambda () 
                                   (set! again #f)
                                   (k #t)))))
                 (test2)
                 (set! v 3))
               (display v)
               (set! v 4)
               (if again (again)))

             (define (test2) (display v))       

             (test1)                    --&gt; 12134
</pre>

<p><dt>
<code>(CASE-LAMBDA &lt;clause&gt; ...)</code>
<br> Syntax
<dd>
<p>Each &lt;clause&gt; should have the form (&lt;formals&gt; &lt;body&gt;), where 
   &lt;formals&gt; is a formal arguments list as for LAMBDA, cf section
   4.1.4 of the R5RS.  Each &lt;body&gt; is a &lt;tail-body&gt;, cf section
   3.5 of the R5RS.

<p>A <code>CASE-LAMBDA</code> expression evaluates to a procedure that accepts
   a variable number of arguments and is lexically scoped in the
   same manner as procedures resulting from LAMBDA expressions.  
   When the procedure is called with some arguments V1 .. Vk, then
   the first &lt;clause&gt; for which the arguments agree with &lt;formals&gt; 
   is selected, where agreement is specified as for the &lt;formals&gt; 
   of a <code>LAMBDA</code> expression.  The variables of &lt;formals&gt; are bound 
   to fresh locations, the values V1 .. Vk are stored in those 
   locations, the &lt;body&gt; is evaluated in the extended environment,
   and the results of &lt;body&gt; are returned as the results of the 
   procedure call.

<p>It is an error for the arguments not to agree with the &lt;formals&gt;
   of any &lt;clause&gt;.

<pre>
             (define plus
               (case-lambda 
                 (() 0)
                 ((x) x)
                 ((x y) (+ x y))
                 ((x y z) (+ (+ x y) z))
                 (args (apply + args))))

             (plus)                     --&gt; 0
             (plus 1)                   --&gt; 1
             (plus 1 2 3)               --&gt; 6

             ((case-lambda 
               ((a) a)
               ((a b) (* a b)))
              1 2 3)                    --&gt; error
</pre>
</dl>

<H1>Implementation</H1>

The following implementation is written in R5RS Scheme.  It is not
compatible with the IEEE Scheme standard because the IEEE standard does
not contain the high-level macro system.

<p>The implementation assumes that some top-level names defined by the
R5RS are bound to their original values.

<p>
<pre>
(define-syntax let-values
  (syntax-rules ()
    ((let-values (formals e0) e1 e2 ...)
     (call-with-values
      (lambda ()
        e0)
      (lambda formals e1 e2 ...)))))

(define-syntax fluid-let
  (syntax-rules ()
    ((_ ((v1 e1) ...) b1 b2 ...)
     (fluid-let "temps" () ((v1 e1) ...) b1 b2 ...))
    ((_ "temps" (t ...) ((v1 e1) x ...) b1 b2 ...)
     (let ((temp e1))
       (fluid-let "temps" ((temp e1 v1) t ...) (x ...) b1 b2 ...)))
    ((_ "temps" ((t e v) ...) () b1 b2 ...)
     (let-syntax ((swap!
                   (syntax-rules ()
                     ((swap! a b)
                      (let ((tmp a))
                        (set! a b)
                        (set! b tmp))))))
       (dynamic-wind
        (lambda ()
          (swap! t v) ...)
        (lambda ()
          b1 b2 ...)
        (lambda ()
          (swap! t v) ...))))))

(define-syntax case-lambda
  (syntax-rules ()
    ((case-lambda 
      (?a1 ?e1 ...) 
      ?clause1 ...)
     (lambda args
       (let ((l (length args)))
         (case-lambda "CLAUSE" args l 
           (?a1 ?e1 ...)
           ?clause1 ...))))
    ((case-lambda "CLAUSE" ?args ?l 
      ((?a1 ...) ?e1 ...) 
      ?clause1 ...)
     (if (= ?l (length '(?a1 ...)))
         (apply (lambda (?a1 ...) ?e1 ...) ?args)
         (case-lambda "CLAUSE" ?args ?l 
           ?clause1 ...)))
    ((case-lambda "CLAUSE" ?args ?l
      ((?a1 . ?ar) ?e1 ...) 
      ?clause1 ...)
     (case-lambda "IMPROPER" ?args ?l 1 (?a1 . ?ar) (?ar ?e1 ...) 
       ?clause1 ...))
    ((case-lambda "CLAUSE" ?args ?l 
      (?a1 ?e1 ...)
      ?clause1 ...)
     (let ((?a1 ?args))
       ?e1 ...))
    ((case-lambda "CLAUSE" ?args ?l)
     (error "Wrong number of arguments to CASE-LAMBDA."))
    ((case-lambda "IMPROPER" ?args ?l ?k ?al ((?a1 . ?ar) ?e1 ...)
      ?clause1 ...)
     (case-lambda "IMPROPER" ?args ?l (+ ?k 1) ?al (?ar ?e1 ...) 
      ?clause1 ...))
    ((case-lambda "IMPROPER" ?args ?l ?k ?al (?ar ?e1 ...) 
      ?clause1 ...)
     (if (>= ?l ?k)
         (apply (lambda ?al ?e1 ...) ?args)
         (case-lambda "CLAUSE" ?args ?l 
           ?clause1 ...)))))
</pre>

<H1>Copyright</H1>
Copyright (C) Lars T Hansen (1999). All Rights Reserved. 
<p>
This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it
or assist in its implementation may be prepared, copied, published and
distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are
included on all such copies and derivative works. However, this
document itself may not be modified in any way, such as by removing
the copyright notice or references to the Scheme Request For
Implementation process or editors, except as needed for the purpose of
developing SRFIs in which case the procedures for copyrights defined
in the SRFI process must be followed, or as required to translate it
into languages other than English.
<p>
The limited permissions granted above are perpetual and will not be
revoked by the authors or their successors or assigns.
<p>
This document and the information contained herein is provided on an
"AS IS" basis and THE AUTHOR AND THE SRFI EDITORS DISCLAIM ALL
WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY
WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY
RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
PARTICULAR PURPOSE.


    <hr>
    <address>Editor: <a href="mailto:srfi-editors@schemers.org">Mike Sperber</a></address>
<!-- Created: Tue Sep 29 19:20:08 EDT 1998 -->
<!-- hhmts start -->
Last modified: Tue Sep 14 15:18:29 MST 1999
<!-- hhmts end -->
  </body>
</html>

